import java.util.*;
import java.io.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.text.JTextComponent.*;
/**
 * Javokapi represents an abstraction between the C details of Okapi and Java. This class
 * allows students to avoid the details of how Okapi works and its command prompt interface.
 * This class can be used to create index, index Okapi DB and use the BSS command interface
 * through Java mappings of these commands into Java. 
 * This class must be placed in the "bin" directory. Also the directories "bibfiles","databases",
 * and "lib" must be present. It is assumed that this class is used in Unix environment. Before this 
 * class is to be used, the following command should be issued in the javokapi directory: <br>
 *             source environmentSettings.cshrc <br>
 * This file contains the environment variables needed for Okapi. Every environment variable is documented.
 *  
 * @author (Hashmatullah Rohian) 
 * @version (Aug16)
 */
public class javokapi{
    // JNI pointer 
    private relex jC;
    /**
     * Constructs a javokapi object with initially created Okapi JNI.
     */
    public javokapi(){
        //makeOkapi();
        //buildJNI();
        jC = new relex();
        jC.x = new relex();        
        jC.x.javainit();
    }
	
	public String oddFind(){
        return jC.x.comm("f   s=0   w=4.068   s=1   w=6.018   s=2   w=6.784   s=3   w=4.089   s=4   w=5.502   op=bm25 ");
	}	



    /**
     * Given a valid command runnable on a Unix shell and the current working Unix directory,
     * runs the command as a new thread.
     *
     * @param cmd represents the Unix command
     * @param dir represents the directory where this command should be executed
     * @return the output generated by the Unix shell
     */
    public String runCommand(String cmd, String dir) {
        String output ="";
        try{
            Process proc = Runtime.getRuntime().exec(cmd, null, new File(dir));
            InputStream inputStream = proc.getInputStream();
            InputStream errorStream = proc.getErrorStream();
        
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
            InputStreamReader errorStreamReader = new InputStreamReader(errorStream);
        
            BufferedReader inputBufferedReader = new BufferedReader(inputStreamReader);
            BufferedReader errorBufferedReader = new BufferedReader(errorStreamReader);
        
            // read the output
    
            String line;
            while ((line = inputBufferedReader.readLine()) != null) {
                output = output + line+ "\n";
            }
            while ((line = errorBufferedReader.readLine()) != null) {
                output = output + line + "\n";
            }
        
            // check for command failure
    
            try {
                if (proc.waitFor() != 0) {
                    System.err.println("exit value = " + proc.exitValue());
                }
            }
            catch (InterruptedException e) {
                System.err.println(e);
            }
            System.out.println(output);
        }catch(IOException e){
            System.err.println(e);
        }
        return output;
    }
    /**
     * Builds the Okapi system and copies the generated files to the proper directories.
     * @return the output generated by the Unix shell
     */
    public String makeOkapi(){
       String out = runCommand("sh makeOkapi.sh", System.getenv("OKAPI_BINDIR"));
       return out;
    }
    /**
     * Builds the Okapi Java Native Interface.
     * @return the output generated by the Unix shell
     */
    public String buildJNI(){
       String out = runCommand("sh build_jni.sh", System.getenv("OKAPI_BINDIR"));
       return out;
    }
    /**
     * Given the name of the Java program responsible for generating exchange format of the given corpus,
     * compiles the Java program and generates the exchange format using Piccolo XML parser named output into the parse directory.
     * 
     * @param parser name of the Java parser program without extension
     * @param corpus name of the data collection
     * @param output name of the parsed output without extension i.e. no ".exch"
     * @return the output generated by the Unix shell
     */
    public String exchangeFormat(String parser, String corpus, String output){
        String parsePath = System.getenv("OKAPI_PARSE");
        String out = "";
        out = out + runCommand("javac "+ parser +".java", parsePath);
	out = out + runCommand("rm -rf " + output +".exch ge2sent1.exch", parsePath);
        out = out + runCommand("java -cp .:Piccolo.jar " + parser + " " + corpus +  " " + output, parsePath);
        return out;
    }
     /**
     * Given the name of main parameter file responsible for generating runtime format,
     * converts the already parsed data and generates the runtime format into the bibfiles directory.
     * 
     * @param param name of the main parameter file
     * @param parsed name of the parsed data with no extension i.e. no ".exch"
     * @return the output generated by the Unix shell and Okapi
     */
    
    public void runtimeFormat(String param, String parsed){
        String paramPath= System.getenv("BSS_PARMPATH")+"";
        String parsePath = System.getenv("OKAPI_PARSE");
        String binPath= System.getenv("OKAPI_BINDIR")+"";
	System.out.println(binPath);
	//"./convert_runtime -c " + paramPath + "/ " + param + " < " + parsePath + "/" + parsed+".exch";
        runCommand("sh runtime.sh 2004gendoc gen_exch", binPath);
    }
     /**
     * Given the name of the main parameter file responsible for generating index of the
     * runtime format, converts the already parsed data and generates the runtime format into the bibfiles directory.
     * 
     * @param param name of the main parameter file
     * @param mem the unit of memory used to create the database, the unit is 1 MB, default 4
     * @param delfinal deletes/doesn't delete the temporary files after final merge.
     * @param doclens contributes/doesn't contribute to the doclength file
     * @param indexNumber Set in param.search_groups file in databases directory. Must be within the range in the database parameter.
     * @return the output generated by the Unix shell and Okapi
     */
    
    public void createIndex(String param, long mem, boolean delfinal, boolean doclens, long indexNumber){
        String binPath= System.getenv("OKAPI_BINDIR")+"";
        if (delfinal && doclens) 
            runCommand("sh create_index.sh " + mem +" delfinal doclens " +param + " " + indexNumber, binPath);
        else if (delfinal)
            runCommand("sh create_index.sh " + mem +" delfinal nodoclens " +param + " " + indexNumber, binPath);
        else if (doclens)
            runCommand("sh create_index.sh " + mem +" nodelfinal doclens " +param + " " + indexNumber, binPath);
        else
            runCommand("sh create_index.sh " + mem +" nodelfinal nodoclens " +param + " " + indexNumber, binPath);
    }
    //uses the Notepad class to open the dbName file in directory folder
    private void openFile(String directory, String dbName){
        JFrame f = new JFrame();
        Notepad applet = new Notepad();
        f.setTitle(directory + dbName);
        f.setBackground(Color.lightGray);
        f.getContentPane().add(applet, BorderLayout.CENTER);
        f.addWindowListener(new appCloseL());
        f.setSize(800, 500);
        f.setVisible(true);
        applet.openFile(directory, dbName);
    }
    /**
     * Launches a Notepad window to edit the main parameter file using the BSS_PARAMPATH environment
     * variable default set to databases directory. This file is used for converting the parsed data
     * and creating indexes.
     * @param dbName name of the main parameter file
     */
    public void setMainParameter(String dbName){
        openFile(System.getenv("BSS_PARMPATH"), dbName);
    }
    /**
     * Launches a Notepad window to edit the DB field types parameter file using the BSS_PARAMPATH environment
     * variable default set to databases directory. Each database has a single field type parameter file called <db_name>.field_types.
     * This file is used for converting the parsed data and creating indexes.
     * @param dbName name of the field types parameter file without extension
     */
    public void setFieldTypesParamFile(String dbName){
        openFile(System.getenv("BSS_PARMPATH"), dbName+".field_types");
    }
   /**
     * Launches a Notepad window to edit the DB search groups parameter file using the BSS_PARAMPATH environment
     * variable default set to databases directory. Each database has a single search groups parameter file called <db_name>.search_groups.
     * There is one entry per DB index in this file. This file is used for converting the parsed data and creating indexes.
     * @param dbName name of the search groups parameter file without extension
     */
    public void setSearchGroupsParamFile(String dbName){
        openFile(System.getenv("BSS_PARMPATH"), dbName+".search_groups");
    }
    /**
     * Chooses the given Okapi database, resets all values to their defaults and destroys any existing search sets.
     * @param dbName name of the Okapi database to be chosen and opened
     * @return output generated by Okapi
     * 
     */
    public String chooseDB(String dbName){
        return jC.x.comm("ch " + dbName);
    }
     /**
     * infoDB requests information about the available databases.
     * @return a line containing "<n> database(s)" followed by a line for each available database consisting of the database name followed by a very brief description.
     */
    public String infoDB(){
        return jC.x.comm("info databases");
    }
    /**
     * Parses the string into individual terms in a form suitable for looking up in the database. Used to determine what terms to look for.
     * @param attribute determines the type of data which will be searched, i.e. which index, and, for some kinds of index, the class of objects within that index. There is always a default attribute, which may be referred to as "default". Typically, this is some kind of general keyword attribute. It is defined by the first entry in the database's search_groups file. Usually there also exists an attribute called "dn" (document number). Apart from these two, the only way to determine what attributes there are for a database is to look at the   search_groups parameter file for the database, although if the database manager is sensible they will have fairly self-evident names like "ti", "au", "ab". A non-existent attribute mnemonic causes a NO_SUCH_ATTRIBUTE error.
     * @param term a given string to be parsed
     * @return  <number of non-stopped terms>   [t=<term>]..  The number may of course be 0. Only indexed terms are output.
     */
    public String parse(String attribute, String term){
        if (attribute.trim().length()!=0){
            return jC.x.comm("parse attribute="+attribute+" t="+term);
        }else{
            return jC.x.comm("parse"+" t="+term);
        }
    }
    /**
     * Parses the string into individual terms in a form suitable for looking up in the database. Used to determine what terms to look for. As PARSE except that more information is given, and terms are output even if they are not indexed (in which case they have GSL class H or F.
     * @param attribute determines the type of data which will be searched, i.e. which index, and, for some kinds of index, the class of objects within that index. There is always a default attribute, which may be referred to as "default". Typically, this is some kind of general keyword attribute. It is defined by the first entry in the database's search_groups file. Usually there also exists an attribute called "dn" (document number). Apart from these two, the only way to determine what attributes there are for a database is to look at the   search_groups parameter file for the database, although if the database manager is sensible they will have fairly self-evident names like "ti", "au", "ab". A non-existent attribute mnemonic causes a NO_SUCH_ATTRIBUTE error.
     * @param term a given string to be parsed
     * @return   <number of terms>   [t=<term>   c=<    gsl class    >   s=<source>]   ..  <source> is the portion of the input which gave rise to this term.
     */    
    public String superParse(String attribute, String term){
        if (attribute.trim().length()!=0){
            return jC.x.comm("superparse attribute="+attribute+" t="+term);
        }else{
            return jC.x.comm("superparse"+" t="+term);
        }
    }
    /**
     * Applies the named function to the given term. There is no default stem function.This utility function is independent of the current database (if any). Even if there is an open database the stemmed term may not occur in any of the database's indexes. Note that the <term> is treated by the stem function as if it were a single word. An unrecognized stem function gives NO_SUCH_STEMFUNCTION error.
     * @param stemFunction name of the stem function
     * @param term String term to be stemmed
     * @return  t=<stemmed term>
     */
    public String stem(String stemFunction, String term){
        return jC.x.comm("stem stemfunction="+stemFunction+" t="+term);
    }
    /**
     * Given the qualifiers, find the one term in the Okapi database.
     * @save Values can be y | 1 | n | 0. Default is 1. y and 1 are synonyms as are n and 0. If save=y or 1 (default) a set is made, otherwise no set is made. save=n may be faster if you only want to find the number of postings for a term, and there will be no unwanted set to be deleted.
     * @type -2 | -1 | 0 | 1 | 2. Default is 0.  -2 finds the greatest term less than the specified term. -1 finds the greatest term not greater than the specified term. 0 (default) finds the specified term or nothing. 1 finds the least term not less than the specified term. 2 finds the least term greater than the specified term.      
     * @param attribute determines the type of data which will be searched, i.e. which index, and, for some kinds of index, the class of objects within that index. There is always a default attribute, which may be referred to as "default" (e.g. in a    SET command). Typically, this is some kind of general keyword attribute. It is defined by the first entry in the database's search_groups file. Usually there also exists an attribute called "dn" (document number). Apart from these two, the only way to determine what attributes there are for a database is to look at the   search_groups parameter file for the database, although if the database manager is sensible they will have fairly self-evident names like "ti", "au", "ab". A non-existent attribute mnemonic causes a NO_SUCH_ATTRIBUTE error.
     * @param term  one term only to be found
     * @return   [ s<n> ]   np=<np>   t=<term found>  <term found> will be empty (nothing following the "t=") if type=0 and specified term is not in the index or type is nonzero and an extremity of the index has been reached.
     */ 
    public String find(String save, String type, String attribute, String term){
        String att = (attribute.trim().length()!=0)?" attribute=" + attribute.trim()+" ": "";
        String sv = (save.trim().length()!=0)?"save=" + save.trim()+" ": "";
        String typ = (type.trim().length()!=0)?" type=" + type.trim()+" ": "";
        return jC.x.comm("find "+ sv + typ + att+ "t="+term);
    }
    /**
     * Given the set number and possibly other paramters, find the set in the Okapi database.
     * @param setnumber the number of a set which has been created and not deleted. Set numbers run from zero. There is a limit on the number of sets, currently about 1000. Deleted setnumbers are reused, always lowest free setnumber first. A non-existent set causes a NO_SUCH_SET error.
     * @param weight must be determined by using the weight command. If weights are derived in some other way they must be smallish integers, typically in the range 1-200; weight "overflow" (> 32767) is not detected and will give spurious ordering of retrieved documents.
     * @param option may be given in any order (but must follow all sets or set/weight pairs). Redundant options are ignored. If an option is repeated the last occurrence is used. Please visit http://www.soi.city.ac.uk/~andym/OKAPI-PACK/appendix-j.html#find2 for more detail on options.
     * @return for non-weighted operation: [S<n> ]   np=<np>    For weighted operation: [S<n> ]   np=<np>   maxwt=<maxwt>   nmaxwt=<# with max wt>   ngw=<ngw>   mpw=<max poss wt>   mpw=<# with max poss wt>   
     */ 
    public String setFind(String setnumber, String weight, String option){
        String wt = (weight.trim().length()!=0)?" w=" + weight.trim()+" ": " ";
        String op = (option.trim().length()!=0)?" op=" + option.trim()+" ": " ";
        //System.out.println("find "+ setnumber + wt + op);
        return jC.x.comm("find "+ "s="+setnumber + wt + op);
    }
    /**
     * Weights the term based on the number of posting and other argument. Usually used after a find method. Note that the big-N argument (number of indexed documents) required by the Robertson/Sparck Jones functions cannot be supplied by the user; it is determined automatically. If there is a need for it a facility may be provided for allowing the user process to supply a big-N value.A function other than 0-2 will be reported as NO_SUCH_WEIGHTFUNC; failure to supply a value for n gives SYNTAX; phoney values of n, r, bigr, rload and bigrload don't generate an error (perhaps they should), weight is usually returned as 0 or 1. 
     * A function other than 0-2 will be reported as NO_SUCH_WEIGHTFUNC; failure to supply a value for n gives SYNTAX; phoney values of n, r, bigr, rload and bigrload don't generate an error (perhaps they should), weight is usually returned as 0 or 1.
     * @param funcno fn=1 with n, r and R gives a    Robertson/Sparck Jones (R/S-J) F4 predictive weight, with halves. fn=0 is the same as f=1 with r=R=0 (i.e. with no relevance information). fn=2 adds r_load and R_load to r and R (resp) in the numerator ("p"-portion) of the R/S-J F4 function. Default 0. Not settable. 
     * @param np the number of postings for the term (<np> from a find command)
     * @param r The number of relevant documents containing the term which is being weighted. Default 0. Not settable.
     * @param bigr The number of relevant documents. Default 0. Settable.
     * @param rload Default 0. Settable.
     * @param bigrload Default 0. Settable.
     * @return a relevance weight as a 16-bit integer (10 * a log to base 2).
     */
    public String weight(String funcno, String np, String r, String bigr, String rload, String bigrload){
		String fn1 = (funcno.trim().length()!=0)?" fn=" + funcno.trim()+" ": "";
	    String r1 = (r.trim().length()!=0)?" r=" + r.trim()+" ": "";
        String bigr1 = (bigr.trim().length()!=0)?" bigr=" + bigr.trim()+" ": "";
        String rload1 = (rload.trim().length()!=0)?" rload=" + rload.trim()+" ": "";
        String bigrload1 = (bigrload.trim().length()!=0)?" bigrload=" + bigrload.trim()+" ": "";
        return jC.x.comm("weight"+ fn1 + " n=" + np + r1+bigr1+rload1+bigrload1);
    }
    /**
     * A direct request by primary key (normally a sequential record number which runs from 1 to the number of records in the database). No set need have been formed. No default. Not settable. Error: RECORD_OUT_OF_RANGE_DB. For more info, visit http://www.soi.city.ac.uk/~andym/OKAPI-PACK/appendix-j.html#show
     * @param format . The initial default format is 1, which works with any database, and delivers a complete record in the form
     *                  <br>Record n
     *                  Weight w
     *                  <fdnum>: contents
     *                  ................ <br>
     *                  Empty fields are not shown. Where fields end with a linefeed (databases of type "text") there may be one or more empty lines between fields. Other databases (abstracting and indexing databases) do not normally contain linefeeds, and one linefeed is inserted at the end of each nonempty field. Can throw NO_SUCH_FORMAT.<br>
     *                  197   	shows field 1 and weight.<br>
     *                  100 	Like format 197 but gives more information provided the set has paragraph information (was retrieved using BM250).<br>
     *                  0   	 delivers the contents of field 1 only. By convention this is a document ID or <docno> (not the same as recnum).<br>
     *                  3 / 259 	These are provisional formats and may change. They are intended for applications where the originating system wants to process the documents for itself. They deliver the entire unprocessed text of a database record preceded by a header. The two formats are identical except that 3 does not contain highlighting records (the "number of highlight records" field contains zero). The header consists of a sequence of ASCII numbers right justified and character strings left justified in fields of fixed length as shown in the table below. 
     * @param recnum database record number
     * @return record requested based on the given format.
     */

    public String showRecord(String format, String recnum){
        String fm = (format.trim().length()!=0)?" format=" + format.trim()+" ": "";
        return jC.x.comm("show " + fm + "r="+recnum);
    }
    /**
     * A request for a record from a set. In this case records are numbered from zero to one less than the number in the set. Errors: NO_SUCH_SET, NO_SUCH_RECORD. For more info, visit http://www.soi.city.ac.uk/~andym/OKAPI-PACK/appendix-j.html#show
     * @param format . The initial default format is 1, which works with any database, and delivers a complete record in the form
     *                  <br>Record n
     *                  Weight w
     *                  <fdnum>: contents
     *                  ................ <br>
     *                  Empty fields are not shown. Where fields end with a linefeed (databases of type "text") there may be one or more empty lines between fields. Other databases (abstracting and indexing databases) do not normally contain linefeeds, and one linefeed is inserted at the end of each nonempty field. Can throw NO_SUCH_FORMAT.<br>
     *                  197   	shows field 1 and weight.<br>
     *                  100 	Like format 197 but gives more information provided the set has paragraph information (was retrieved using BM250).<br>
     *                  0   	 delivers the contents of field 1 only. By convention this is a document ID or <docno> (not the same as recnum).<br>
     *                  3 / 259 	These are provisional formats and may change. They are intended for applications where the originating system wants to process the documents for itself. They deliver the entire unprocessed text of a database record preceded by a header. The two formats are identical except that 3 does not contain highlighting records (the "number of highlight records" field contains zero). The header consists of a sequence of ASCII numbers right justified and character strings left justified in fields of fixed length as shown in the table below. 
     * @param num number of records requested. It defaults to 1. The set defaults to the most recent set formed or from which a record has been shown. 
     * @param record defaults to the next one, or the first if it is the first show command on a new default set. If record is specified it becomes the new default value. Not settable, except implicitly. Errors: NO_SUCH_RECORD.
     * @param setnumber If set is specified it becomes the new default value. Set is not settable, except implicitly. Errors: NO_SUCH_SET
     * @return Record requested based on the given format. 
     */
    public String showSetRecord(String format, String num, String record, String setnumber){
        String fm = (format.trim().length()!=0)?" f=" + format.trim()+" ": "";
        String nm = (num.trim().length()!=0)?" n=" + num.trim()+" ":"";
        String rec = (record.trim().length()!=0)?" r=" + record.trim()+" ":"";
        String setn = (setnumber.trim().length()!=0)?" s=" + setnumber.trim()+" ":"";
        //System.out.println("s " + fm + nm + rec+setn);
        return jC.x.comm("s " + fm + nm + rec+setn);
    }
    /**
     * Deletes the sets given by number. There are no errors, even if invalid set number.
     * @param setnumber set to be deleted.
     * @return output generated by Okapi
     */
    public String deleteRecord(String setnumber){
        return jC.x.comm("delete s="+setnumber );
    }
    /**
     * Displays the current  settings (this is the only default setting command which works when there is no database open).
     * @return current default settings
     */
    public String viewOkapiSettings(){
        return jC.x.comm("set");
    }
    /**
     * Deletes all sets. 
     * @return output generated by Okapi
     */
    public String deleteAllSets(){
        return jC.x.comm("delete all");
    }
    /**
     * Default is default.  	 Error: NO_SUCH_ATTRIBUTE
     * This command can only be used when the database is open.
     * @param attribute  determines the type of data which will be searched, i.e. which index, and, for some kinds of index, the class of objects within that index. There is always a default attribute, which may be referred to as "default" (e.g. in a    SET command). Typically, this is some kind of general keyword attribute. It is defined by the first entry in the database's search_groups file. Usually there also exists an attribute called "dn" (document number). Apart from these two, the only way to determine what attributes there are for a database is to look at the   search_groups parameter file for the database, although if the database manager is sensible they will have fairly self-evident names like "ti", "au", "ab". A non-existent attribute mnemonic causes a NO_SUCH_ATTRIBUTE error.
     * @return output generated by Okapi
     */
    public String setDefaultAttribute(String attribute){
        return jC.x.comm("set attribute="+attribute);
    }
    /**
     * Values are 0 | n | 1 | y | Y | t | T 0 & n are equivalent as are 1, y, Y, t & T. Default is 1. Error: none 
     * This command can only be used when the database is open.
     * @param save y and 1 are synonyms as are n and 0. If save=y or 1 (default) a set is made, otherwise no set is made. save=n may be faster if you only want to find the number of postings for a term, and there will be no unwanted set to be deleted.
     * @return output generated by Okapi
     */
    public String setDefaultSave(char save){
        return jC.x.comm("set save="+save);
    }
    /**
     * Values are -2 | -1 | 0 | 1 | 2. Default is 0. There are no errors, but a value which can't be read as an integer in this range is ignored.
     * This command can only be used when the database is open.
     * @param searchType -2 finds the greatest term less than the specified term. -1 finds the greatest term not greater than the specified term. 0 (default) finds the specified term or nothing. 1 finds the least term not less than the specified term. 2 finds the least term greater than the specified term.      
     * @return output generated by Okapi
     */
    public String setDefaultSearchType(long searchType){
        return jC.x.comm("set search_type="+searchType);
    }
    /**
     * Values are 0 | 1. Default is 0. 
     * This command can only be used when the database is open.
     * @param nopos If nopos=1 no positional data or term frequencies are output. This speeds a large combine operation, reducing output substantially, and is sometimes useful in batch processing. If a set was produced with nopos=1 few subsequent operations can be done on it, nor can highlighted output be obtained. 
     * @return output generated by Okapi
     */
    public String setDefaultNoPos(long nopos){
        return jC.x.comm("set nopos="+nopos);
    }
    /**
     * Default is 0.0  	 Anything which doesn't look like a number gives SYNTAX.
     * This command can only be used when the database is open.
     * @param k1 constant in Robertson Selection Value Model.For ops bm1100/1500/250/2500. Ignored by other ops. For bm11/15/25 k1 values are in the database parameter and cannot be varied.
     * @return output generated by Okapi
     */
    public String setDefaultK1(double k1){
        return jC.x.comm("set k1="+k1);
    }
    /**
     * Default is 0.0   Anything which doesn't look like a number gives SYNTAX.
     * This command can only be used when the database is open.
     * @param k2 constant in Robertson Selection Value Model. The global doclength correction parameter for ops bm1100/1500/250/2500. Ignored by other ops. For bm11/15/25 k2-values are in the database parameter and cannot be varied.
     * @return output generated by Okapi
     */
    public String setDefaultK2(double k2){
        return jC.x.comm("set k2="+k2);
    }
    /**
     * Default is 0.0   Anything which doesn't look like a number gives SYNTAX.
     * This command can only be used when the database is open.
     * @param BM25_number constant in Robertson Selection Value Model. The b parameter for ops BM250/2500. Ignored by other ops. For BM25 b-values are in the database parameter and cannot be varied.
     * @return output generated by Okapi
     */
     
    public String setDefaultBM25_number(double BM25_number){
        return jC.x.comm("set BM25_b="+BM25_number);
    }
    /**
     * Default is 0.0  	 Anything which doesn't look like a number gives SYNTAX.
     * This command can only be used when the database is open.
     * @param k3 constant in Robertson Selection Value Model.For ops bm1100/1500/250/2500. Ignored by other ops. For bm11/15/25 k4 values are in the database parameter and cannot be varied.
     * @return output generated by Okapi
     */
    public String setDefaultK3(double k3){
        return jC.x.comm("set k3="+k3);
    }
    /**
     * Value is a positive integer. Default is 1. Anything which doesn't look like a number gives SYNTAX; values less than 1 are ignored.
     * This command can only be used when the database is open.
     * @param passage_unit constant in BM250.
     * @return output generated by Okapi
     */
    public String setDefaultPassageUnit(long passage_unit){
        return jC.x.comm("set passage_unit="+passage_unit);
    }
    /**
     * Value is a positive integer. Default is 1. Anything which doesn't look like a number gives SYNTAX; values less than 1 are ignored.
     * This command can only be used when the database is open.
     * @param passage_step constant in BM250.
     * @return output generated by Okapi
     */
    public String setDefaultPassageStep(long passage_step){
        return jC.x.comm("set passage_step="+passage_step);
    }
    /**
     * Value is a positive integer. Default is 20. Anything which doesn't look like a number gives SYNTAX; values less than 1 are ignored.
     * This command can only be used when the database is open.
     * @param passage_maxlen constant in BM250.
     * @return output generated by Okapi
     */
    public String setDefaultPassageMaxLength(long passage_maxlen){
        return jC.x.comm("set passage_maxlen="+passage_maxlen);
    }
    /**
     * Value is a non-negative integer. Default is 0. Anything which doesn't look like a number gives SYNTAX; values less than 0 are ignored.
     * This command can only be used when the database is open.
     * @param bigr The number of relevant documents. 
     * @return output generated by Okapi
     */
    public String setDefaultBigR(long bigr){
        return jC.x.comm("set bigr="+bigr);
    }
    /**
     * Value is a non-negative integer. Default is 0. Anything which doesn't look like a number gives SYNTAX; values less than 0 are ignored.
     * This command can only be used when the database is open.
     * @param bigrload 
     * @return output generated by Okapi
     */
    public String setDefaultBigrload(long bigrload){
        return jC.x.comm("set bigrload="+bigrload);
    }
    /**
     * Value is a non-negative integer. Default is 0. Anything which doesn't look like a number gives SYNTAX; values less than 0 are ignored.
     * This command can only be used when the database is open.
     * @param rload 
     * @return output generated by Okapi
     */
    public String setDefaultRload(long rload){
        return jC.x.comm("set rload="+rload);
    }
    /**
     * Option name value are available is found here http://www.soi.city.ac.uk/~andym/OKAPI-PACK/appendix-j.html#find2 Default is bm1. Errors are NO_SUCH_OP, SYNTAX.
     * This command can only be used when the database is open.
     * @param op 
     * @return output generated by Okapi
     */
    public String setDefaultOptions(String op){
        return jC.x.comm("set op="+op);
    }
    /**
     * Exhibit database.
     * @return outputs "No database" if none open, otherwise the database name.
     */
    public String displayDatabases(){
        return jC.x.comm("display database" );
    }
    /**
     * Exhibit stemfunctions which are psstem | wstem | sstem | nostem
     * @return Outputs the names of the available stemming functions, one per line, preceded by a line of the form "<n> function(s)". 
     */
    public String displayStemFunctions(){
        return jC.x.comm("display stemfunctions" );
    }
    /**
     * This command may be used on any set, but at present the only sets which may give nonzero statistics are ones obtained by using a Robertson limit (op=and2 or op=not2). Errors: NO_SUCH_SET
     * @param setnmuber the set to exhibit info about
     * @return Outputs "sum=<sum of weights in set> sumsq=<sum of squares of weights in set". If no set is specified the "current" set is assumed. Using this command does not alter the system's notion of current set. 
     */
    public String displayStats(long setnumber){
        return jC.x.comm("displaystats set="+setnumber);
    }
    //used for 
    private static final class appCloseL extends WindowAdapter
    {
        public void windowClosing(WindowEvent e)
        {
            System.exit(0);
        }
    }
}


